generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PunchType {
  CLOCK_IN
  CLOCK_OUT
  BREAK_START
  BREAK_END
}

enum PunchSource {
  NORMAL
  CORRECTION
}

enum AttendanceCorrectionStatus {
  PENDING
  REJECTED
  APPROVED
  CANCELED
}

/// 勤怠修正イベント種別（申請/差し戻し/承認/取り下げ）
enum AttendanceCorrectionEventType {
  REQUESTED
  REJECTED
  APPROVED
  CANCELED
}

enum RuleTargetAction {
  CLOCK_IN
  CLOCK_OUT
  BREAK_START
  BREAK_END
}

enum RuleType {
  ALLOW_CLOCK_IN_ONLY_BEFORE_TIME
  ALLOW_CLOCK_OUT_ONLY_AFTER_TIME
}

model AttendanceRecord {
  id          String                 @id @default(ulid())
  userId      String
  workDate    DateTime               @db.Date
  punchEvents AttendancePunchEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, workDate])
  @@map("attendance_records")
}

//勤怠の事実をそのままイベントとして持っているため(状態遷移するわけではない)
model AttendancePunchEvent {
  id                 String           @id @default(ulid())
  attendanceRecordId String
  attendanceRecord   AttendanceRecord @relation(fields: [attendanceRecordId], references: [id], onDelete: Cascade)

  punchType  PunchType
  occurredAt DateTime
  createdAt  DateTime  @default(now())

  source   PunchSource
  sourceId String? // PunchSourceがCORRECTION の場合だけ埋める（通常はnull）

  // NOTE:
  // 冪等性をDBで強く担保したい場合、
  // Postgresの「部分ユニークインデックス（WHERE source='CORRECTION'）」が理想だが
  // Prisma schema だけでは表現できないので migration.sql に追記するのが安全。
  //
  // 例（migration.sqlに追記する想定）:
  // CREATE UNIQUE INDEX attendance_punches_correction_unique
  // ON attendance_punches (source, source_id, punch_type)
  // WHERE source = 'CORRECTION';

  @@index([attendanceRecordId, occurredAt])
  @@index([attendanceRecordId, createdAt])
  @@index([source, sourceId])
  @@map("attendance_punch_events")
}

model AttendanceCorrection {
  id       String   @id @default(ulid())
  userId   String
  workDate DateTime // 可能なら @db.Date を検討（「日」ならDateが安全）
  reason   String // 申請理由（必要ならREQUESTEDイベントのreasonと同じにする）

  events AttendanceCorrectionEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, workDate])
  @@map("attendance_corrections")
}

model AttendanceCorrectionEvent {
  id                     String               @id @default(ulid())
  attendanceCorrectionId String
  attendanceCorrection   AttendanceCorrection @relation(fields: [attendanceCorrectionId], references: [id], onDelete: Cascade)

  type        AttendanceCorrectionEventType
  occurredAt  DateTime // REQUESTEDのrequestedAt / APPROVEDのapprovedAt / REJECTEDのrejectedAt / CANCELEDのcanceledAt
  actorUserId String // requestedBy / approvedBy / rejectedBy / canceledBy

  reason  String? // REQUESTED / 再申請時のみ
  comment String? // REJECTED時のみ

  // 修正対象のPunch群（将来の複数対応のためJsonで保持）
  // 例: [{ "punchType": "CLOCK_IN", "occurredAt": "2024-01-15T01:05:00.000Z" }]
  punches Json? //REQUESTED / APPROVEDはpunchesが存在するがREJECTED / CANCELEDではpunchesが存在しない

  createdAt DateTime @default(now())

  @@index([attendanceCorrectionId, createdAt])
  @@index([attendanceCorrectionId, type])
  @@map("attendance_correction_events")
}

model AttendanceRule {
  id        String             @id @default(ulid())
  targets   RuleTargetAction[]
  type      RuleType
  setting   Json
  enabled   Boolean            @default(true)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  @@index([enabled, type])
  @@map("attendance_rules")
}
